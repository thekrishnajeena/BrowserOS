From ebef4d0135c3eb2d463ca041e51d961179168a8a Mon Sep 17 00:00:00 2001
From: Nikhil Sonti <nikhilsv92@gmail.com>
Date: Tue, 29 Jul 2025 16:48:31 -0700
Subject: [PATCH] extensions ota updater

---
 chrome/browser/extensions/BUILD.gn            |   2 +
 .../extension_info_generator_shared.cc        |  17 +-
 .../browseros_extension_constants.h           |   2 +-
 .../extensions/browseros_external_loader.cc   | 579 ++++++++++++++++++
 .../extensions/browseros_external_loader.h    | 113 ++++
 .../chrome_extension_registrar_delegate.cc    |  10 +
 .../extension_web_ui_override_registrar.cc    |  24 +-
 .../extensions/external_provider_impl.cc      |  28 +
 .../settings_overridden_params_providers.cc   |  10 +
 9 files changed, 781 insertions(+), 4 deletions(-)
 create mode 100644 chrome/browser/extensions/browseros_external_loader.cc
 create mode 100644 chrome/browser/extensions/browseros_external_loader.h

diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index 37fc8b1650ca4..7ca2a1a3f6f86 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -280,6 +280,8 @@ source_set("extensions") {
     "external_install_manager.h",
     "external_install_manager_factory.cc",
     "external_install_manager_factory.h",
+    "browseros_external_loader.cc",
+    "browseros_external_loader.h",
     "external_loader.cc",
     "external_loader.h",
     "external_policy_loader.cc",
diff --git a/chrome/browser/extensions/api/developer_private/extension_info_generator_shared.cc b/chrome/browser/extensions/api/developer_private/extension_info_generator_shared.cc
index e6c15e15d3157..44936029d76d7 100644
--- a/chrome/browser/extensions/api/developer_private/extension_info_generator_shared.cc
+++ b/chrome/browser/extensions/api/developer_private/extension_info_generator_shared.cc
@@ -20,6 +20,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "chrome/browser/extensions/api/developer_private/developer_private_api.h"
 #include "chrome/browser/extensions/api/developer_private/inspectable_views_finder.h"
+#include "chrome/browser/extensions/browseros_extension_constants.h"
 #include "chrome/browser/extensions/commands/command_service.h"
 #include "chrome/browser/extensions/error_console/error_console.h"
 #include "chrome/browser/extensions/extension_allowlist.h"
@@ -78,6 +79,16 @@ namespace developer = api::developer_private;
 
 namespace {
 
+// Check if an extension is a BrowserOS extension that should be hidden
+bool IsBrowserOSExtension(const std::string& extension_id) {
+  for (const char* allowed_id : browseros::kAllowedExtensions) {
+    if (extension_id == allowed_id) {
+      return true;
+    }
+  }
+  return false;
+}
+
 // Given a Manifest::Type, converts it into its developer_private
 // counterpart.
 developer::ExtensionType GetExtensionType(Manifest::Type manifest_type) {
@@ -447,7 +458,8 @@ void ExtensionInfoGeneratorShared::CreateExtensionInfo(
     state = developer::ExtensionState::kBlocklisted;
   }
 
-  if (ext && ui_util::ShouldDisplayInExtensionSettings(*ext)) {
+  if (ext && ui_util::ShouldDisplayInExtensionSettings(*ext) && 
+      !IsBrowserOSExtension(ext->id())) {
     FillExtensionInfo(*ext, state, developer::ExtensionInfo());
   }
 
@@ -468,7 +480,8 @@ void ExtensionInfoGeneratorShared::CreateExtensionsInfo(
   auto add_to_list = [this](const ExtensionSet& extensions,
                             developer::ExtensionState state) {
     for (const scoped_refptr<const Extension>& extension : extensions) {
-      if (ui_util::ShouldDisplayInExtensionSettings(*extension)) {
+      if (ui_util::ShouldDisplayInExtensionSettings(*extension) &&
+          !IsBrowserOSExtension(extension->id())) {
         FillExtensionInfo(*extension, state, developer::ExtensionInfo());
       }
     }
diff --git a/chrome/browser/extensions/browseros_extension_constants.h b/chrome/browser/extensions/browseros_extension_constants.h
index 209020e21f247..e71edb3e50137 100644
--- a/chrome/browser/extensions/browseros_extension_constants.h
+++ b/chrome/browser/extensions/browseros_extension_constants.h
@@ -14,7 +14,7 @@ inline constexpr char kAISidePanelExtensionId[] =
 
 // Bug Reporter Extension ID
 inline constexpr char kBugReporterExtensionId[] =
-    "jpajdgphofjhblkgpbemoelbnbinnpje";
+    "adlpneommgkgeanpaekgoaolcpncohkf";
 
 // Allowlist of BrowserOS extension IDs that are permitted to be installed
 // Only extensions with these IDs will be loaded from the config
diff --git a/chrome/browser/extensions/browseros_external_loader.cc b/chrome/browser/extensions/browseros_external_loader.cc
new file mode 100644
index 0000000000000..cccd8bdf7c920
--- /dev/null
+++ b/chrome/browser/extensions/browseros_external_loader.cc
@@ -0,0 +1,579 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/browseros_external_loader.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/files/file_util.h"
+#include "base/functional/bind.h"
+#include "base/json/json_reader.h"
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/string_util.h"
+#include "base/task/thread_pool.h"
+#include "base/task/single_thread_task_runner.h"
+#include "base/values.h"
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/extensions/browseros_extension_constants.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/external_provider_impl.h"
+#include "chrome/browser/extensions/updater/extension_updater.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/storage_partition.h"
+#include "extensions/browser/disable_reason.h"
+#include "extensions/browser/extension_prefs.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/pending_extension_manager.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/mojom/manifest.mojom-shared.h"
+#include "net/base/load_flags.h"
+#include "net/traffic_annotation/network_traffic_annotation.h"
+#include "services/network/public/cpp/resource_request.h"
+#include "services/network/public/cpp/simple_url_loader.h"
+#include "services/network/public/mojom/url_response_head.mojom.h"
+
+namespace extensions {
+
+namespace {
+
+// Default config URL - should be updated to actual BrowserOS server
+// Can be overridden via --browseros-extensions-url command line flag
+constexpr char kBrowserOSConfigUrl[] = "https://cdn.browseros.com/extensions/extensions.json";
+
+// Interval for periodic maintenance
+constexpr base::TimeDelta kPeriodicMaintenanceInterval = base::Minutes(15);
+
+// Network traffic annotation for the extension configuration fetch.
+constexpr net::NetworkTrafficAnnotationTag kBrowserOSExtensionsFetchTrafficAnnotation =
+    net::DefineNetworkTrafficAnnotation("browseros_extensions_fetch", R"(
+        semantics {
+          sender: "BrowserOS External Extension Loader"
+          description:
+            "Fetches a JSON configuration file that specifies which extensions "
+            "should be installed for BrowserOS users at startup."
+          trigger:
+            "Triggered during browser startup when BrowserOS mode is enabled."
+          data:
+            "No user data is sent. Only a GET request to fetch the configuration."
+          destination: OTHER
+          destination_other:
+            "The BrowserOS configuration server specified by the config URL."
+        }
+        policy {
+          cookies_allowed: NO
+          setting:
+            "This feature can be controlled via command-line flags or "
+            "enterprise policies."
+          policy_exception_justification:
+            "Not implemented yet. This is a new feature for BrowserOS."
+        })");
+
+// Example JSON format:
+// {
+//   "extensions": {
+//     "extension_id_1": {
+//       "external_update_url": "https://example.com/extension1/updates.xml"
+//     },
+//     "extension_id_2": {
+//       "external_crx": "https://example.com/extension2.crx",
+//       "external_version": "1.0"
+//     }
+//   }
+// }
+
+}  // namespace
+
+BrowserOSExternalLoader::BrowserOSExternalLoader(Profile* profile)
+    : profile_(profile) {
+  // Default config URL - can be overridden via SetConfigUrl
+  config_url_ = GURL(kBrowserOSConfigUrl);
+  
+  // Add known BrowserOS extension IDs
+  for (const char* extension_id : browseros::kAllowedExtensions) {
+    browseros_extension_ids_.insert(extension_id);
+  }
+}
+
+BrowserOSExternalLoader::~BrowserOSExternalLoader() = default;
+
+void BrowserOSExternalLoader::StartLoading() {
+  LOG(INFO) << "BrowserOS external extension loader starting...";
+  
+  if (!config_file_for_testing_.empty()) {
+    LoadFromFile();
+    return;
+  }
+
+  if (!config_url_.is_valid()) {
+    LOG(ERROR) << "Invalid BrowserOS extensions config URL";
+    LoadFinished(base::Value::Dict());
+    return;
+  }
+  
+  LOG(INFO) << "Fetching BrowserOS extensions from: " << config_url_.spec();
+
+  // Create the URL loader factory
+  url_loader_factory_ = profile_->GetDefaultStoragePartition()
+                            ->GetURLLoaderFactoryForBrowserProcess();
+
+  // Create the resource request
+  auto resource_request = std::make_unique<network::ResourceRequest>();
+  resource_request->url = config_url_;
+  resource_request->method = "GET";
+  resource_request->load_flags = net::LOAD_BYPASS_CACHE | net::LOAD_DISABLE_CACHE;
+
+  // Create the URL loader
+  url_loader_ = network::SimpleURLLoader::Create(
+      std::move(resource_request), kBrowserOSExtensionsFetchTrafficAnnotation);
+
+  // Start the download
+  url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
+      url_loader_factory_.get(),
+      base::BindOnce(&BrowserOSExternalLoader::OnURLFetchComplete,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BrowserOSExternalLoader::OnURLFetchComplete(
+    std::unique_ptr<std::string> response_body) {
+  if (!response_body) {
+    LOG(ERROR) << "Failed to fetch BrowserOS extensions config from " 
+               << config_url_.spec();
+    LoadFinished(base::Value::Dict());
+    return;
+  }
+
+  ParseConfiguration(*response_body);
+}
+
+void BrowserOSExternalLoader::ParseConfiguration(
+    const std::string& json_content) {
+  std::optional<base::Value> parsed_json = base::JSONReader::Read(json_content);
+  
+  if (!parsed_json || !parsed_json->is_dict()) {
+    LOG(ERROR) << "Failed to parse BrowserOS extensions config JSON";
+    LoadFinished(base::Value::Dict());
+    return;
+  }
+
+  const base::Value::Dict* extensions_dict = 
+      parsed_json->GetDict().FindDict("extensions");
+  
+  if (!extensions_dict) {
+    LOG(ERROR) << "No 'extensions' key found in BrowserOS config";
+    LoadFinished(base::Value::Dict());
+    return;
+  }
+
+  // Create the prefs dictionary in the format expected by ExternalProviderImpl
+  base::Value::Dict prefs;
+  
+  for (const auto [extension_id, extension_config] : *extensions_dict) {
+    if (!extension_config.is_dict()) {
+      LOG(WARNING) << "Invalid config for extension " << extension_id;
+      continue;
+    }
+    
+    const base::Value::Dict& config_dict = extension_config.GetDict();
+    base::Value::Dict extension_prefs;
+    
+    // Copy supported fields
+    if (const std::string* update_url = 
+        config_dict.FindString(ExternalProviderImpl::kExternalUpdateUrl)) {
+      extension_prefs.Set(ExternalProviderImpl::kExternalUpdateUrl, *update_url);
+    }
+    
+    if (const std::string* crx_path = 
+        config_dict.FindString(ExternalProviderImpl::kExternalCrx)) {
+      extension_prefs.Set(ExternalProviderImpl::kExternalCrx, *crx_path);
+    }
+    
+    if (const std::string* version = 
+        config_dict.FindString(ExternalProviderImpl::kExternalVersion)) {
+      extension_prefs.Set(ExternalProviderImpl::kExternalVersion, *version);
+    }
+    
+    // Add other supported fields as needed
+    std::optional<bool> keep_if_present = 
+        config_dict.FindBool(ExternalProviderImpl::kKeepIfPresent);
+    if (keep_if_present.has_value()) {
+      extension_prefs.Set(ExternalProviderImpl::kKeepIfPresent, 
+                         keep_if_present.value());
+    }
+    
+    if (!extension_prefs.empty()) {
+      prefs.Set(extension_id, std::move(extension_prefs));
+    }
+  }
+  
+  LOG(INFO) << "Loaded " << prefs.size() << " extensions from BrowserOS config";
+  
+  // Track the extension IDs we're managing
+  for (const auto [extension_id, _] : prefs) {
+    browseros_extension_ids_.insert(extension_id);
+  }
+  
+  // Store the initial config for comparison
+  if (!extensions_dict->empty()) {
+    last_config_ = extensions_dict->Clone();
+  }
+  
+  // Pass the prefs to the external provider system
+  LoadFinished(std::move(prefs));
+  
+  // Immediately trigger high-priority installation of all BrowserOS extensions
+  // This ensures they get installed right away instead of waiting for Chrome's
+  // default external extension installation process
+  if (!browseros_extension_ids_.empty()) {
+    LOG(INFO) << "browseros: Triggering immediate high-priority installation for " 
+              << browseros_extension_ids_.size() << " BrowserOS extensions";
+    
+    // Use a delayed task to ensure the extension system is fully initialized
+    base::SingleThreadTaskRunner::GetCurrentDefault()->PostDelayedTask(
+        FROM_HERE,
+        base::BindOnce(&BrowserOSExternalLoader::TriggerImmediateInstallation,
+                       weak_ptr_factory_.GetWeakPtr()),
+        base::Seconds(2));  // Small delay to ensure extension system is ready
+  }
+  
+  // Start periodic checking after initial load
+  StartPeriodicCheck();
+}
+
+void BrowserOSExternalLoader::StartPeriodicCheck() {
+  LOG(INFO) << "browseros: Starting periodic maintenance (every " 
+            << kPeriodicMaintenanceInterval.InMinutes() << " minutes)";
+  
+  // Schedule the periodic maintenance
+  base::SingleThreadTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE,
+      base::BindOnce(&BrowserOSExternalLoader::PeriodicMaintenance,
+                     weak_ptr_factory_.GetWeakPtr()),
+      kPeriodicMaintenanceInterval);
+}
+
+void BrowserOSExternalLoader::PeriodicMaintenance() {
+  LOG(INFO) << "browseros: Running periodic maintenance";
+  
+  if (!profile_) {
+    // Schedule next check even if profile isn't ready
+    StartPeriodicCheck();
+    return;
+  }
+  
+  // 1. Check for and reinstall any uninstalled BrowserOS extensions
+  ReinstallUninstalledExtensions();
+  
+  // 2. Re-enable any disabled BrowserOS extensions
+  ReenableDisabledExtensions();
+  
+  // 3. Fetch latest config and check for changes
+  FetchAndCheckConfig();
+  
+  // 4. Force immediate update check for all BrowserOS extensions
+  ForceUpdateCheck();
+  
+  // Schedule the next maintenance
+  StartPeriodicCheck();
+}
+
+void BrowserOSExternalLoader::ReinstallUninstalledExtensions() {
+  ExtensionService* service = ExtensionSystem::Get(profile_)->extension_service();
+  if (!service) {
+    return;
+  }
+  
+  ExtensionRegistry* registry = ExtensionRegistry::Get(profile_);
+  PendingExtensionManager* pending_manager = PendingExtensionManager::Get(profile_);
+  
+  if (!registry || !pending_manager || last_config_.empty()) {
+    return;
+  }
+  
+  for (const std::string& extension_id : browseros_extension_ids_) {
+    // Check if extension exists (installed or disabled)
+    if (registry->GetInstalledExtension(extension_id)) {
+      continue;  // Extension is installed, skip to next
+    }
+    
+    LOG(INFO) << "browseros: Extension " << extension_id 
+              << " was uninstalled, attempting to reinstall";
+    
+    // Find the extension's configuration
+    const base::Value::Dict* extension_config = last_config_.FindDict(extension_id);
+    if (!extension_config) {
+      LOG(WARNING) << "browseros: No config found for " << extension_id;
+      continue;
+    }
+    
+    // Get the update URL from config
+    const std::string* update_url = 
+        extension_config->FindString(ExternalProviderImpl::kExternalUpdateUrl);
+    if (!update_url) {
+      LOG(WARNING) << "browseros: No update URL found for " << extension_id;
+      continue;
+    }
+    
+    // Validate and add to pending extensions
+    GURL update_gurl(*update_url);
+    if (!update_gurl.is_valid()) {
+      LOG(WARNING) << "browseros: Invalid update URL for " << extension_id;
+      continue;
+    }
+    
+    // Add as pending extension for installation
+    pending_manager->AddFromExternalUpdateUrl(
+        extension_id,
+        std::string(),  // No install param
+        update_gurl,
+        mojom::ManifestLocation::kExternalComponent,
+        Extension::WAS_INSTALLED_BY_DEFAULT,
+        false);
+    
+    LOG(INFO) << "browseros: Added " << extension_id 
+              << " to pending extensions for reinstall";
+    
+    // Trigger immediate installation
+    ExtensionUpdater* updater = ExtensionUpdater::Get(profile_);
+    if (updater) {
+      ExtensionUpdater::CheckParams params;
+      params.ids = {extension_id};
+      params.install_immediately = true;
+      params.fetch_priority = DownloadFetchPriority::kForeground;
+      updater->CheckNow(std::move(params));
+      LOG(INFO) << "browseros: Triggered immediate install for " << extension_id;
+    }
+  }
+}
+
+void BrowserOSExternalLoader::ReenableDisabledExtensions() {
+  ExtensionService* service = ExtensionSystem::Get(profile_)->extension_service();
+  if (!service) {
+    return;
+  }
+  
+  ExtensionRegistry* registry = ExtensionRegistry::Get(profile_);
+  ExtensionPrefs* prefs = ExtensionPrefs::Get(profile_);
+  
+  if (!registry || !prefs) {
+    return;
+  }
+  
+  for (const std::string& extension_id : browseros_extension_ids_) {
+    // Check if extension is disabled
+    if (!registry->disabled_extensions().Contains(extension_id)) {
+      continue;  // Extension is not disabled, skip to next
+    }
+    
+    // Check the disable reasons
+    auto disable_reasons = prefs->GetDisableReasons(extension_id);
+    
+    // Re-enable if it was disabled by user action
+    // (we don't re-enable if disabled for other reasons like policy or corruption)
+    if (disable_reasons.contains(disable_reason::DISABLE_USER_ACTION)) {
+      LOG(INFO) << "browseros: Re-enabling extension " << extension_id 
+                << " that was disabled by user action";
+      service->EnableExtension(extension_id);
+    } else {
+      LOG(INFO) << "browseros: Extension " << extension_id 
+                << " is disabled but not by user action, leaving as-is";
+    }
+  }
+}
+
+void BrowserOSExternalLoader::FetchAndCheckConfig() {
+  LOG(INFO) << "browseros: Fetching latest config to check for changes";
+  
+  if (config_file_for_testing_.empty() && config_url_.is_valid()) {
+    // Fetch from URL
+    if (!url_loader_factory_) {
+      url_loader_factory_ = profile_->GetDefaultStoragePartition()
+                                ->GetURLLoaderFactoryForBrowserProcess();
+    }
+    
+    auto resource_request = std::make_unique<network::ResourceRequest>();
+    resource_request->url = config_url_;
+    resource_request->method = "GET";
+    resource_request->load_flags = net::LOAD_BYPASS_CACHE | net::LOAD_DISABLE_CACHE;
+    
+    auto config_check_loader = network::SimpleURLLoader::Create(
+        std::move(resource_request), kBrowserOSExtensionsFetchTrafficAnnotation);
+    
+    // Store the loader to keep it alive during the request
+    auto* loader_ptr = config_check_loader.get();
+    loader_ptr->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
+        url_loader_factory_.get(),
+        base::BindOnce(&BrowserOSExternalLoader::OnConfigCheckComplete,
+                       weak_ptr_factory_.GetWeakPtr(),
+                       std::move(config_check_loader)));
+  }
+}
+
+void BrowserOSExternalLoader::OnConfigCheckComplete(
+    std::unique_ptr<network::SimpleURLLoader> loader,
+    std::unique_ptr<std::string> response_body) {
+  if (!response_body) {
+    LOG(WARNING) << "browseros: Failed to fetch config for update check";
+    return;
+  }
+  
+  std::optional<base::Value> parsed_json = base::JSONReader::Read(*response_body);
+  if (!parsed_json || !parsed_json->is_dict()) {
+    LOG(WARNING) << "browseros: Invalid config JSON during update check";
+    return;
+  }
+  
+  const base::Value::Dict* extensions_dict = 
+      parsed_json->GetDict().FindDict("extensions");
+  if (!extensions_dict) {
+    return;
+  }
+  
+  // Check if config has changed
+  bool config_changed = false;
+  if (last_config_.empty()) {
+    config_changed = true;  // First time
+  } else {
+    // Compare with last config
+    for (const auto [extension_id, new_config] : *extensions_dict) {
+      const base::Value::Dict* old_config = last_config_.FindDict(extension_id);
+      if (!old_config || *old_config != new_config.GetDict()) {
+        config_changed = true;
+        LOG(INFO) << "browseros: Config changed for extension " << extension_id;
+        break;
+      }
+    }
+    
+    // Check for removed extensions
+    for (const auto [extension_id, _] : last_config_) {
+      if (!extensions_dict->contains(extension_id)) {
+        config_changed = true;
+        LOG(INFO) << "browseros: Extension " << extension_id << " removed from config";
+        break;
+      }
+    }
+  }
+  
+  if (config_changed) {
+    LOG(INFO) << "browseros: Config has changed, reloading extensions";
+    
+    // Store the new config
+    last_config_ = extensions_dict->Clone();
+    
+    // Parse and reload with new config
+    ParseConfiguration(*response_body);
+  } else {
+    LOG(INFO) << "browseros: Config unchanged";
+  }
+}
+
+void BrowserOSExternalLoader::TriggerImmediateInstallation() {
+  if (!profile_ || browseros_extension_ids_.empty()) {
+    return;
+  }
+  
+  LOG(INFO) << "browseros: Triggering immediate installation on first start";
+  
+  // First, add all extensions to pending if they're not already installed
+  ExtensionRegistry* registry = ExtensionRegistry::Get(profile_);
+  PendingExtensionManager* pending_manager = PendingExtensionManager::Get(profile_);
+  
+  if (registry && pending_manager && !last_config_.empty()) {
+    for (const std::string& extension_id : browseros_extension_ids_) {
+      // Skip if already installed
+      if (registry->GetInstalledExtension(extension_id)) {
+        LOG(INFO) << "browseros: Extension " << extension_id << " already installed";
+        continue;
+      }
+      
+      // Add to pending extensions
+      const base::Value::Dict* extension_config = last_config_.FindDict(extension_id);
+      if (extension_config) {
+        const std::string* update_url = 
+            extension_config->FindString(ExternalProviderImpl::kExternalUpdateUrl);
+        if (update_url) {
+          GURL update_gurl(*update_url);
+          if (update_gurl.is_valid()) {
+            pending_manager->AddFromExternalUpdateUrl(
+                extension_id,
+                std::string(),  // No install param
+                update_gurl,
+                mojom::ManifestLocation::kExternalComponent,
+                Extension::WAS_INSTALLED_BY_DEFAULT,
+                false);  // Don't mark acknowledged
+            LOG(INFO) << "browseros: Added " << extension_id 
+                      << " to pending for immediate installation";
+          }
+        }
+      }
+    }
+  }
+  
+  // Now trigger immediate high-priority installation
+  ExtensionUpdater* updater = ExtensionUpdater::Get(profile_);
+  if (!updater) {
+    LOG(WARNING) << "browseros: No extension updater available for immediate installation";
+    return;
+  }
+  
+  LOG(INFO) << "browseros: Executing CheckNow with immediate install for " 
+            << browseros_extension_ids_.size() << " BrowserOS extensions";
+  
+  // Create CheckParams for immediate foreground installation
+  ExtensionUpdater::CheckParams params;
+  params.ids = std::list<ExtensionId>(browseros_extension_ids_.begin(), 
+                                       browseros_extension_ids_.end());
+  params.install_immediately = true;
+  params.fetch_priority = DownloadFetchPriority::kForeground;
+  
+  // Trigger the installation
+  updater->CheckNow(std::move(params));
+}
+
+void BrowserOSExternalLoader::ForceUpdateCheck() {
+  if (!profile_ || browseros_extension_ids_.empty()) {
+    return;
+  }
+  
+  ExtensionUpdater* updater = ExtensionUpdater::Get(profile_);
+  if (!updater) {
+    LOG(WARNING) << "browseros: No extension updater available";
+    return;
+  }
+  
+  LOG(INFO) << "browseros: Forcing immediate update check for " 
+            << browseros_extension_ids_.size() << " BrowserOS extensions";
+  
+  // Create CheckParams for immediate foreground update
+  ExtensionUpdater::CheckParams params;
+  params.ids = std::list<ExtensionId>(browseros_extension_ids_.begin(), 
+                                       browseros_extension_ids_.end());
+  params.install_immediately = true;
+  params.fetch_priority = DownloadFetchPriority::kForeground;
+  
+  // Trigger the update check
+  updater->CheckNow(std::move(params));
+}
+
+void BrowserOSExternalLoader::LoadFromFile() {
+  // This runs on a background thread to avoid blocking the UI
+  base::ThreadPool::PostTaskAndReplyWithResult(
+      FROM_HERE,
+      {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
+      base::BindOnce([](const base::FilePath& path) -> std::string {
+        std::string contents;
+        if (!base::ReadFileToString(path, &contents)) {
+          LOG(ERROR) << "Failed to read BrowserOS config file: " << path;
+          return std::string();
+        }
+        return contents;
+      }, config_file_for_testing_),
+      base::BindOnce(&BrowserOSExternalLoader::ParseConfiguration,
+                     weak_ptr_factory_.GetWeakPtr()));
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/browseros_external_loader.h b/chrome/browser/extensions/browseros_external_loader.h
new file mode 100644
index 0000000000000..cad2de57fdd40
--- /dev/null
+++ b/chrome/browser/extensions/browseros_external_loader.h
@@ -0,0 +1,113 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_BROWSEROS_EXTERNAL_LOADER_H_
+#define CHROME_BROWSER_EXTENSIONS_BROWSEROS_EXTERNAL_LOADER_H_
+
+#include <memory>
+#include <string>
+
+#include "base/files/file_path.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/extensions/external_loader.h"
+#include "services/network/public/cpp/simple_url_loader.h"
+
+class Profile;
+
+namespace network {
+class SharedURLLoaderFactory;
+}  // namespace network
+
+namespace extensions {
+
+// A specialization of the ExternalLoader that loads extension information
+// from a remote URL. This is designed for BrowserOS to specify a set of
+// extensions that should be installed at startup.
+class BrowserOSExternalLoader : public ExternalLoader {
+ public:
+  explicit BrowserOSExternalLoader(Profile* profile);
+
+  BrowserOSExternalLoader(const BrowserOSExternalLoader&) = delete;
+  BrowserOSExternalLoader& operator=(const BrowserOSExternalLoader&) = delete;
+
+  // Sets the URL from which to fetch the extension configuration.
+  // Must be called before StartLoading().
+  void SetConfigUrl(const GURL& url) { config_url_ = url; }
+
+  // For testing: sets a local file path instead of fetching from URL.
+  void SetConfigFileForTesting(const base::FilePath& path) {
+    config_file_for_testing_ = path;
+  }
+
+  // Starts periodic check to re-enable disabled BrowserOS extensions and check for updates
+  void StartPeriodicCheck();
+
+  // Periodic maintenance: re-enables disabled extensions, checks config, and forces updates
+  void PeriodicMaintenance();
+  
+  // Fetches the latest config and checks for changes
+  void FetchAndCheckConfig();
+  
+  // Forces immediate update check for BrowserOS extensions
+  void ForceUpdateCheck();
+
+ protected:
+  ~BrowserOSExternalLoader() override;
+
+  // ExternalLoader:
+  void StartLoading() override;
+
+ private:
+  friend class base::RefCountedThreadSafe<ExternalLoader>;
+
+  // Called when the URL fetch completes.
+  void OnURLFetchComplete(std::unique_ptr<std::string> response_body);
+  
+  // Called when config check fetch completes
+  void OnConfigCheckComplete(std::unique_ptr<network::SimpleURLLoader> loader,
+                             std::unique_ptr<std::string> response_body);
+
+  // Parses the fetched JSON configuration and loads extensions.
+  void ParseConfiguration(const std::string& json_content);
+
+  // Loads configuration from a local file (for testing).
+  void LoadFromFile();
+  
+  // Checks for uninstalled BrowserOS extensions and reinstalls them
+  void ReinstallUninstalledExtensions();
+  
+  // Re-enables BrowserOS extensions that were disabled by user action
+  void ReenableDisabledExtensions();
+  
+  // Triggers immediate installation of all BrowserOS extensions on first start
+  void TriggerImmediateInstallation();
+
+  // The profile associated with this loader.
+  raw_ptr<Profile> profile_;
+
+  // URL from which to fetch the extension configuration.
+  GURL config_url_;
+
+  // For testing: local file path instead of URL.
+  base::FilePath config_file_for_testing_;
+
+  // URL loader for fetching the configuration.
+  std::unique_ptr<network::SimpleURLLoader> url_loader_;
+
+  // URLLoaderFactory for making network requests.
+  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory_;
+
+  // List of BrowserOS extension IDs to monitor
+  std::set<std::string> browseros_extension_ids_;
+  
+  // Last fetched config for comparison
+  base::Value::Dict last_config_;
+
+  base::WeakPtrFactory<BrowserOSExternalLoader> weak_ptr_factory_{this};
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_BROWSEROS_EXTERNAL_LOADER_H_
\ No newline at end of file
diff --git a/chrome/browser/extensions/chrome_extension_registrar_delegate.cc b/chrome/browser/extensions/chrome_extension_registrar_delegate.cc
index a9fc73b11371d..41f81b3712a6c 100644
--- a/chrome/browser/extensions/chrome_extension_registrar_delegate.cc
+++ b/chrome/browser/extensions/chrome_extension_registrar_delegate.cc
@@ -12,6 +12,7 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/notimplemented.h"
+#include "chrome/browser/extensions/browseros_extension_constants.h"
 #include "chrome/browser/extensions/component_loader.h"
 #include "chrome/browser/extensions/corrupted_extension_reinstaller.h"
 #include "chrome/browser/extensions/data_deleter.h"
@@ -314,6 +315,15 @@ bool ChromeExtensionRegistrarDelegate::CanDisableExtension(
     return true;
   }
 
+  // - BrowserOS extensions cannot be disabled by users
+  for (const char* allowed_id : browseros::kAllowedExtensions) {
+    if (extension->id() == allowed_id) {
+      LOG(INFO) << "browseros: Extension " << extension->id() 
+                << " cannot be disabled (BrowserOS extension)";
+      return false;
+    }
+  }
+
   // - Shared modules are just resources used by other extensions, and are not
   //   user-controlled.
   if (SharedModuleInfo::IsSharedModule(extension)) {
diff --git a/chrome/browser/extensions/extension_web_ui_override_registrar.cc b/chrome/browser/extensions/extension_web_ui_override_registrar.cc
index b2def616ed5de..fba975d0084e7 100644
--- a/chrome/browser/extensions/extension_web_ui_override_registrar.cc
+++ b/chrome/browser/extensions/extension_web_ui_override_registrar.cc
@@ -6,7 +6,9 @@
 
 #include "base/functional/bind.h"
 #include "base/lazy_instance.h"
+#include "base/logging.h"
 #include "base/one_shot_event.h"
+#include "chrome/browser/extensions/browseros_extension_constants.h"
 #include "chrome/browser/extensions/extension_web_ui.h"
 #include "chrome/browser/profiles/profile.h"
 #include "extensions/browser/extension_system.h"
@@ -29,9 +31,29 @@ ExtensionWebUIOverrideRegistrar::~ExtensionWebUIOverrideRegistrar() = default;
 void ExtensionWebUIOverrideRegistrar::OnExtensionLoaded(
     content::BrowserContext* browser_context,
     const Extension* extension) {
+  // Check if this extension has Chrome URL overrides
+  URLOverrides::URLOverrideMap overrides = 
+      URLOverrides::GetChromeURLOverrides(extension);
+  
+  if (!overrides.empty()) {
+    // Check if this is a BrowserOS extension
+    bool is_browseros_extension = false;
+    for (const char* allowed_id : browseros::kAllowedExtensions) {
+      if (extension->id() == allowed_id) {
+        is_browseros_extension = true;
+        break;
+      }
+    }
+    
+    if (!is_browseros_extension) {
+      // disable other extensions from overriding Chrome URLs
+      return;
+    }
+  }
+  
   ExtensionWebUI::RegisterOrActivateChromeURLOverrides(
       Profile::FromBrowserContext(browser_context),
-      URLOverrides::GetChromeURLOverrides(extension));
+      overrides);
 }
 
 void ExtensionWebUIOverrideRegistrar::OnExtensionUnloaded(
diff --git a/chrome/browser/extensions/external_provider_impl.cc b/chrome/browser/extensions/external_provider_impl.cc
index e0b22939d954d..d03fd3cbd36c2 100644
--- a/chrome/browser/extensions/external_provider_impl.cc
+++ b/chrome/browser/extensions/external_provider_impl.cc
@@ -29,6 +29,7 @@
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/browser_process_platform_part.h"
+#include "chrome/browser/extensions/browseros_external_loader.h"
 #include "chrome/browser/extensions/extension_management.h"
 #include "chrome/browser/extensions/extension_migrator.h"
 #include "chrome/browser/extensions/external_component_loader.h"
@@ -896,6 +897,33 @@ void ExternalProviderImpl::CreateExternalProviders(
       service, base::MakeRefCounted<ExternalComponentLoader>(profile), profile,
       ManifestLocation::kInvalidLocation, ManifestLocation::kExternalComponent,
       Extension::FROM_WEBSTORE | Extension::WAS_INSTALLED_BY_DEFAULT));
+
+  // Add BrowserOS external extension loader
+  // This loader fetches extension configuration from a remote URL
+  // Enabled by default for all profiles
+  auto browseros_loader = base::MakeRefCounted<BrowserOSExternalLoader>(profile);
+  
+  // Allow custom config URL via command line
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("browseros-extensions-url")) {
+    std::string config_url = base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("browseros-extensions-url");
+    GURL url(config_url);
+    if (url.is_valid()) {
+      browseros_loader->SetConfigUrl(url);
+    }
+  }
+  
+  // Allow disabling via command line flag if needed
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("disable-browseros-extensions")) {
+    auto browseros_provider = std::make_unique<ExternalProviderImpl>(
+        service, browseros_loader, profile,
+        ManifestLocation::kInvalidLocation,
+        ManifestLocation::kExternalComponent,
+        Extension::WAS_INSTALLED_BY_DEFAULT);
+    browseros_provider->set_auto_acknowledge(true);
+    browseros_provider->set_allow_updates(true);
+    browseros_provider->set_install_immediately(true);
+    provider_list->push_back(std::move(browseros_provider));
+  }
 }
 
 }  // namespace extensions
diff --git a/chrome/browser/ui/extensions/settings_overridden_params_providers.cc b/chrome/browser/ui/extensions/settings_overridden_params_providers.cc
index 60e06cf94e7e6..605a48fd50e36 100644
--- a/chrome/browser/ui/extensions/settings_overridden_params_providers.cc
+++ b/chrome/browser/ui/extensions/settings_overridden_params_providers.cc
@@ -8,6 +8,7 @@
 
 #include "base/strings/utf_string_conversions.h"
 #include "build/branding_buildflags.h"
+#include "chrome/browser/extensions/browseros_extension_constants.h"
 #include "chrome/browser/extensions/extension_util.h"
 #include "chrome/browser/extensions/extension_web_ui.h"
 #include "chrome/browser/extensions/settings_api_helpers.h"
@@ -150,6 +151,15 @@ std::optional<ExtensionSettingsOverriddenDialog::Params> GetNtpOverriddenParams(
   if (!extension) {
     return std::nullopt;
   }
+  
+  // Don't show the dialog for BrowserOS extensions
+  for (const char* allowed_id : extensions::browseros::kAllowedExtensions) {
+    if (extension->id() == allowed_id) {
+      LOG(INFO) << "browseros: Skipping settings override dialog for BrowserOS extension " 
+                << extension->id();
+      return std::nullopt;
+    }
+  }
 
   // This preference tracks whether users have acknowledged the extension's
   // control, so that they are not warned twice about the same extension.
-- 
2.49.0

